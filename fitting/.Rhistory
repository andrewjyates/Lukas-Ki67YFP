return(Kplus)
})
}
mSP_YFP <- function(t, state, parms) {
with(as.list(c(state,parms)), {
Y = Y0 + a*(t^b)*exp(-c*t)
return(Y)
})
}
function(t, state, parms){
with(as.list(c(state,parms)),{
dlp = Theta/N * (K_hi_mSP(t, NA, p_mSP_hi) - mSP_YFP(t, NA, p_mSP_YFP)*lp) - beta*lp + 2*p*(1-lp)
dN = Theta*mSP_YFP(t, NA, p_mSP_YFP) +N*(p - mu)
return(list(c(dlp,  dN)))
})
}
}
fun_log <- function (x){
return(log(x))
}
load(file = "../data/DataObjects/final_data_flow_model.RData")
load(file = "../data/DataObjects/final_data_flow_model_v2.RData")
test <- map_depth(final_data_flow_model, 2,~do.call(rbind,.) )
N.and.lp <- map(test, ~merge(.[["Ki67_YFP_frac"]], .[["cell_numbers_YFPpos"]], by = c("time", "celltype")))
N.and.lp <- map2(N.and.lp, names(N.and.lp), ~ mutate(.x, ID = .y))
test <- do.call(rbind,N.and.lp)
N.and.lp <- test %>% group_by(celltype) %>% group_split()
names(N.and.lp) <- c("CD4", "CD8")
N.and.lp <- map(N.and.lp, ~ mutate(., lp = norm_frac_Ki67_YFP, .keep = "unused")%>%
mutate(., N = cell_number_tot, .keep = "unused") )
N.and.lp = map(N.and.lp, ~mutate(., ID= as.numeric(ID)) %>%
filter(., time>=0 & time<80 &!is.na(lp) & !lp == 0) %>%
select(., c("time","lp", "N", "ID" )) %>%
data.frame(.))
# for fitting, subtract 4 from time, so we start at zero, and remove the ID variable
N.and.lp.for.fitting <- map(N.and.lp, ~ mutate(., time = time - 4) %>% select( ., -ID))
s <- c(lp = 0.2, N = 1.5e4)
p <- list("CD4" = c("Theta" = 0.5, "mu" = 0.02, "beta" = 0.3, "p" = 0.005),
"CD8" = c("Theta" = 0.5, "mu" = 0.02, "beta" = 0.3, "p" = 0.005))
free <- list("CD4" = c("Theta", "mu", "beta", "p", "lp", "N"),
"CD8" = c("Theta", "mu", "beta", "p", "lp", "N"))
lower  = list("CD4" = c(rep(0.01, 3), 0.0001, 0.001, 10),
"CD8" = c(rep(0.01, 3), 0.0001, 0.001, 10))
upper = list("CD4" = c(rep(2,4) , 1, 1e5),
"CD8" = c(rep(2,4) , 1, 1e5))
flow_frac_pointest_p_free <- map2(N.and.lp.for.fitting,
names(N.and.lp.for.fitting), ~fit(.x,
parms = p[[.y]],
odes = flow_frac_model(.y),
free = free[[.y]],
#fun = fun_rec,
fun = fun_log,
method = "Pseudo",
show = "lp",
ymax = 1,
#sigma_scale = c(1,0.25), #estimated from data
#bootstrap = nboots,
#bootstrap.residuals=TRUE,
lower  = lower[[.y]],
upper = upper[[.y]]))
shapiro <- map(flow_frac_pointest_p_free, ~shapiro.test(.[["residuals"]]))
save(flow_frac_pointest_p_free, file = "DataObjects/flow_frac_pointest_p_free.RData")
# p=0
s <- c(lp = 0.2, N = 1.5e4)
p <- list("CD4" = c("Theta" = 0.5, "mu" = 0.02, "beta" = 0.3, "p" = 0),
"CD8" = c("Theta" = 0.5, "mu" = 0.02, "beta" = 0.3, "p" = 0))
free <- list("CD4" = c("Theta", "mu", "beta", "lp", "N"),
"CD8" = c("Theta", "mu", "beta", "lp", "N"))
lower  = list("CD4" = c(rep(0.01, 3), 0.001, 10),
"CD8" = c(rep(0.01, 3), 0.001, 10)
)
upper = list("CD4" = c(rep(2,3) , 1, 1e5),
"CD8" = c(rep(2,3) , 1, 1e5))
flow_frac_pointest_p_zero <- map2(N.and.lp.for.fitting,
names(N.and.lp.for.fitting), ~fit(.x,
parms = p[[.y]],
odes = flow_frac_model(.y),
free = free[[.y]],
#fun = fun_rec,
fun = fun_log,
method = "Pseudo",
show = "lp",
ymax = 1,
#sigma_scale = c(1,0.25), #estimated from data
#bootstrap = nboots,
#bootstrap.residuals=TRUE,
lower  = lower[[.y]],
upper = upper[[.y]]))
shapiro <- map(flow_frac_pointest_p_zero, ~shapiro.test(.[["residuals"]]))
save(flow_frac_pointest_p_zero, file = "DataObjects/flow_frac_pointest_p_zero.RData")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
load(file =  "../data/DataObjects/CD4_CD8.RData")
load(file = "../data/DataObjects/final_data_flow_model.RData")
#load("flow_model_together.RData")
packages <- c("tidyverse", "ggplot2")
tmp=lapply(packages, require, character.only = TRUE)
source("grind.R")
# this is code modified from Fitting C - only now we keep Y in it too.
# make a dataframe with Kplus, Y, time, ID
cell_numbers_YFPmSP <- map(CD4_CD8, function(a) filter(a[["cell-numbers-YFPpos"]][["TH"]], grepl("mat", celltype)))
perc_Ki67_YFPmSP <- map(CD4_CD8, function(a) filter(a[["perc Ki67 - YFPpos cells"]][["TH"]], grepl("mat", celltype)))
Y.and.Kplus.for.fitting <- map2(cell_numbers_YFPmSP, perc_Ki67_YFPmSP, ~ merge(.x,.y, by = c("mouse", "time", "ID", "celltype", "tissue"))) %>%
map(~mutate(.,Y = cell_number.x )) %>%
map(~mutate(.,fraction_Ki67 = cell_number.y/100)) %>%
map(~select(., c("time", "Y", "fraction_Ki67", "ID")))
# clean it up a bit ...  We should be left with time-4, Ki67+YFP+ number, YFP+ number.
for(i in c("CD4", "CD8")){
Y.and.Kplus.for.fitting[[i]]=  Y.and.Kplus.for.fitting[[i]] %>%
mutate(Kplus = Y*fraction_Ki67) %>%
mutate(time=time-4) %>%
filter(time>=0) %>%
select(-c(fraction_Ki67))
# set zeros to half lowest value
lowest.nonzero.Kplus=min(filter(Y.and.Kplus.for.fitting[[i]], Kplus>0)$Kplus)
Y.and.Kplus.for.fitting[[i]]$Kplus[Y.and.Kplus.for.fitting[[i]]$Kplus<lowest.nonzero.Kplus] =0.5*lowest.nonzero.Kplus
}
# Now gather data in periphery - from Fitting D
test <- map_depth(final_data_flow_model, 2,~do.call(rbind,.) )
N.and.lp <- map(test, ~merge(.[["Ki67_YFP_frac"]], .[["cell_numbers_YFPpos"]], by = c("time", "celltype")))
N.and.lp <- map2(N.and.lp, names(N.and.lp), ~ mutate(.x, ID = .y))
test <- do.call(rbind,N.and.lp)
N.and.lp <- test %>% group_by(celltype) %>% group_split()
names(N.and.lp) <- c("CD4", "CD8")
N.and.lp <- map(N.and.lp, ~ mutate(., lp = norm_frac_Ki67_YFP, .keep = "unused")%>%
mutate(., N = cell_number_tot, .keep = "unused") )
load("../data/DataObjects/ID_mouseID.Rdata")
ID_mouseID <- ID_mouseID[[1]] # just choose one of them
colnames(ID_mouseID) <- c("ID", "MouseID") # ID is the one we want (1...45)
N.and.lp <- map(N.and.lp, ~merge(., ID_mouseID, by = "ID"))
N.and.lp = map(N.and.lp, ~mutate(., ID= as.numeric(ID)))
N.and.lp.for.fitting <- map(N.and.lp, ~ mutate(., time = time - 4) %>%
filter(., time>=0) %>%
select(., c("time","lp", "N", "ID" )) %>%
data.frame(.))
#Merging data
simultaneous_flow_data_fitting <- map2(Y.and.Kplus.for.fitting, N.and.lp.for.fitting, ~
merge(.x,.y, by = c("time","ID"),all = TRUE))
simultaneous_flow_data_fitting <- map(simultaneous_flow_data_fitting, ~select(., c("time","Kplus", "Y", "lp", "N")))
simultaneous_flow_data_fitting <- map(simultaneous_flow_data_fitting, ~ filter(., time < 80))
simultaneous_flow_data_fitting <- map(simultaneous_flow_data_fitting, ~ filter(., !is.na(lp) & !lp == 0))
simultaneous_flow_data_correct_times <- map(simultaneous_flow_data_fitting, ~ mutate(., time=time+4))
flow_frac <- function(t, state, parms){
with(as.list(c(state,parms)),{
# Thymus functions:
# Kplus = number of Ki67+YFP+ mSPs = assumed to be same functional form as Y
# pars estimated in Fitting C
# Kplus = Kplus0 + a.k*(t^b.k)*exp(-c.k*t)
#
# Y = number of YFP+ mSPs (eqn 3a in text)
# pars estimated in Fitting A
# Y = Y0 + a*(t^b)*exp(-c*t)  #
dKplus = a.k*exp(-c.k*t)*(b.k*(t^(b.k-1)) - c.k*(t^b.k))
dY = a*exp(-c*t)*(b*(t^(b-1)) - c*(t^b))
dlp = Theta/N * (Kplus - Y*lp) - beta*lp+2*p*(1-lp) # fraction Ki67+ of YFP+ naive ("l" in text)
dN = Theta*Y +(p-mu)*N # total YFP+ naive ("L" in text)
return(list(c(dKplus,  dY, dlp, dN)))
})
}
flow_frac_just_thymus <- function(t, state, parms){
with(as.list(c(state,parms)),{
# Thymus functions:
# Kplus = number of Ki67+YFP+ mSPs = assumed to be same functional form as Y
# pars estimated in Fitting C
# Kplus = Kplus0 + a.k*(t^b.k)*exp(-c.k*t)
#
# Y = number of YFP+ mSPs (eqn 3a in text)
# pars estimated in Fitting A
# Y = Y0 + a*(t^b)*exp(-c*t)  #
dKplus = a.k*exp(-c.k*t)*(b.k*(t^(b.k-1)) - c.k*(t^b.k))
dY = a*exp(-c*t)*(b*(t^(b-1)) - c*(t^b))
return(list(c(dKplus,  dY)))
})
}
fun_log <- function (x){
#x[x<0] <- 0
#print(x)
return(log(x))
}
# full fit!
print("Fitting starting... p free\n")
# init conds
s <- c("Kplus" = 200,    #kpos YFP+ cells in thymus
"Y" = 10^3,     #YFP+ cells in thymus
"lp" = 0.2,
"N" = 26000)
# init par guesses
p <- c("a.k" = 1000,
"b.k" = 1.1,
"c.k" = 0.1,
"a" = 2000,
"b" = 1.1,
"c" = 0.2,
"Theta" = 0.7,
"mu" = 0.03,
"beta" = 0.33,
"p" = 0.001)
start_time <- Sys.time()
simultaneous_fit_frac <- map(simultaneous_flow_data_fitting, ~fit(datas = .,
odes = flow_frac,
free = c(names(p),names(s)),
lower = c("a.k" = 10,
"b.k" = 1.0001,
"c.k" = 0.001,
"a" = 500,
"b" = 1.0001,
"c" = 0.01,
"Theta" = 0.1,
"mu" = 0.01,
"beta" = 0.1,
"p" = 0.00001,
"Kplus" = 10,
"Y" = 100,
"lp" = 0.01,
"N" = 1000),
upper = c("a.k" = 5000,
"b.k" = 5,
"c.k" = 2,
"a" = 5000,
"b" = 4,
"c" = 2,
"Theta" = 2,
"mu" = 0.1,
"beta" = 1,
"p" = 0.005,
"Kplus" = 500,
"Y" = 1e5,
"lp" = 0.8,
"N" = 1e7),
method = "Marq",
fun = fun_log
show = NULL
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
load(file =  "../data/DataObjects/CD4_CD8.RData")
load(file = "../data/DataObjects/final_data_flow_model.RData")
#load("flow_model_together.RData")
packages <- c("tidyverse", "ggplot2")
tmp=lapply(packages, require, character.only = TRUE)
source("grind.R")
# this is code modified from Fitting C - only now we keep Y in it too.
# make a dataframe with Kplus, Y, time, ID
cell_numbers_YFPmSP <- map(CD4_CD8, function(a) filter(a[["cell-numbers-YFPpos"]][["TH"]], grepl("mat", celltype)))
perc_Ki67_YFPmSP <- map(CD4_CD8, function(a) filter(a[["perc Ki67 - YFPpos cells"]][["TH"]], grepl("mat", celltype)))
Y.and.Kplus.for.fitting <- map2(cell_numbers_YFPmSP, perc_Ki67_YFPmSP, ~ merge(.x,.y, by = c("mouse", "time", "ID", "celltype", "tissue"))) %>%
map(~mutate(.,Y = cell_number.x )) %>%
map(~mutate(.,fraction_Ki67 = cell_number.y/100)) %>%
map(~select(., c("time", "Y", "fraction_Ki67", "ID")))
# clean it up a bit ...  We should be left with time-4, Ki67+YFP+ number, YFP+ number.
for(i in c("CD4", "CD8")){
Y.and.Kplus.for.fitting[[i]]=  Y.and.Kplus.for.fitting[[i]] %>%
mutate(Kplus = Y*fraction_Ki67) %>%
mutate(time=time-4) %>%
filter(time>=0) %>%
select(-c(fraction_Ki67))
# set zeros to half lowest value
lowest.nonzero.Kplus=min(filter(Y.and.Kplus.for.fitting[[i]], Kplus>0)$Kplus)
Y.and.Kplus.for.fitting[[i]]$Kplus[Y.and.Kplus.for.fitting[[i]]$Kplus<lowest.nonzero.Kplus] =0.5*lowest.nonzero.Kplus
}
# Now gather data in periphery - from Fitting D
test <- map_depth(final_data_flow_model, 2,~do.call(rbind,.) )
N.and.lp <- map(test, ~merge(.[["Ki67_YFP_frac"]], .[["cell_numbers_YFPpos"]], by = c("time", "celltype")))
N.and.lp <- map2(N.and.lp, names(N.and.lp), ~ mutate(.x, ID = .y))
test <- do.call(rbind,N.and.lp)
N.and.lp <- test %>% group_by(celltype) %>% group_split()
names(N.and.lp) <- c("CD4", "CD8")
N.and.lp <- map(N.and.lp, ~ mutate(., lp = norm_frac_Ki67_YFP, .keep = "unused")%>%
mutate(., N = cell_number_tot, .keep = "unused") )
load("../data/DataObjects/ID_mouseID.Rdata")
ID_mouseID <- ID_mouseID[[1]] # just choose one of them
colnames(ID_mouseID) <- c("ID", "MouseID") # ID is the one we want (1...45)
N.and.lp <- map(N.and.lp, ~merge(., ID_mouseID, by = "ID"))
N.and.lp = map(N.and.lp, ~mutate(., ID= as.numeric(ID)))
N.and.lp.for.fitting <- map(N.and.lp, ~ mutate(., time = time - 4) %>%
filter(., time>=0) %>%
select(., c("time","lp", "N", "ID" )) %>%
data.frame(.))
#Merging data
simultaneous_flow_data_fitting <- map2(Y.and.Kplus.for.fitting, N.and.lp.for.fitting, ~
merge(.x,.y, by = c("time","ID"),all = TRUE))
simultaneous_flow_data_fitting <- map(simultaneous_flow_data_fitting, ~select(., c("time","Kplus", "Y", "lp", "N")))
simultaneous_flow_data_fitting <- map(simultaneous_flow_data_fitting, ~ filter(., time < 80))
simultaneous_flow_data_fitting <- map(simultaneous_flow_data_fitting, ~ filter(., !is.na(lp) & !lp == 0))
simultaneous_flow_data_correct_times <- map(simultaneous_flow_data_fitting, ~ mutate(., time=time+4))
flow_frac <- function(t, state, parms){
with(as.list(c(state,parms)),{
# Thymus functions:
# Kplus = number of Ki67+YFP+ mSPs = assumed to be same functional form as Y
# pars estimated in Fitting C
# Kplus = Kplus0 + a.k*(t^b.k)*exp(-c.k*t)
#
# Y = number of YFP+ mSPs (eqn 3a in text)
# pars estimated in Fitting A
# Y = Y0 + a*(t^b)*exp(-c*t)  #
dKplus = a.k*exp(-c.k*t)*(b.k*(t^(b.k-1)) - c.k*(t^b.k))
dY = a*exp(-c*t)*(b*(t^(b-1)) - c*(t^b))
dlp = Theta/N * (Kplus - Y*lp) - beta*lp+2*p*(1-lp) # fraction Ki67+ of YFP+ naive ("l" in text)
dN = Theta*Y +(p-mu)*N # total YFP+ naive ("L" in text)
return(list(c(dKplus,  dY, dlp, dN)))
})
}
flow_frac_just_thymus <- function(t, state, parms){
with(as.list(c(state,parms)),{
# Thymus functions:
# Kplus = number of Ki67+YFP+ mSPs = assumed to be same functional form as Y
# pars estimated in Fitting C
# Kplus = Kplus0 + a.k*(t^b.k)*exp(-c.k*t)
#
# Y = number of YFP+ mSPs (eqn 3a in text)
# pars estimated in Fitting A
# Y = Y0 + a*(t^b)*exp(-c*t)  #
dKplus = a.k*exp(-c.k*t)*(b.k*(t^(b.k-1)) - c.k*(t^b.k))
dY = a*exp(-c*t)*(b*(t^(b-1)) - c*(t^b))
return(list(c(dKplus,  dY)))
})
}
fun_log <- function (x){
#x[x<0] <- 0
#print(x)
return(log(x))
}
# full fit!
print("Fitting starting... p free\n")
# init conds
s <- c("Kplus" = 200,    #kpos YFP+ cells in thymus
"Y" = 10^3,     #YFP+ cells in thymus
"lp" = 0.2,
"N" = 26000)
# init par guesses
p <- c("a.k" = 1000,
"b.k" = 1.1,
"c.k" = 0.1,
"a" = 2000,
"b" = 1.1,
"c" = 0.2,
"Theta" = 0.7,
"mu" = 0.03,
"beta" = 0.33,
"p" = 0.001)
start_time <- Sys.time()
simultaneous_fit_frac <- map(simultaneous_flow_data_fitting, ~fit(datas = .,
odes = flow_frac,
free = c(names(p),names(s)),
lower = c("a.k" = 10,
"b.k" = 1.0001,
"c.k" = 0.001,
"a" = 500,
"b" = 1.0001,
"c" = 0.01,
"Theta" = 0.1,
"mu" = 0.01,
"beta" = 0.1,
"p" = 0.00001,
"Kplus" = 10,
"Y" = 100,
"lp" = 0.01,
"N" = 1000),
upper = c("a.k" = 5000,
"b.k" = 5,
"c.k" = 2,
"a" = 5000,
"b" = 4,
"c" = 2,
"Theta" = 2,
"mu" = 0.1,
"beta" = 1,
"p" = 0.005,
"Kplus" = 500,
"Y" = 1e5,
"lp" = 0.8,
"N" = 1e7),
method = "Marq",
fun = fun_log,
show = NULL
#    ymax = 0.3
#bootstrap = nboots
)
)
end_time <- Sys.time()
print(end_time - start_time)
shapiro <- map(simultaneous_fit_frac, ~shapiro.test(.[["residuals"]]))
flow_sim_frac_pointest_p_free <- simultaneous_fit_frac
save(flow_sim_frac_pointest_p_free, file = "DataObjects/flow_sim_frac_pointest_p_free.Rdata")
cat("p non zero fit done\n")
#restricted fit = p = zero
# init conds
s <- c("Kplus" = 200,    #kpos YFP+ cells in thymus
"Y" = 10^3,     #YFP+ cells in thymus
"lp" = 0.2,
"N" = 26000)
# init par guesses
p <- c("a.k" = 1000,
"b.k" = 1.1,
"c.k" = 0.1,
"a" = 2000,
"b" = 1.1,
"c" = 0.2,
"Theta" = 0.7,
"mu" = 0.03,
"beta" = 0.33,
"p" = 0.0)
freepars = c(names(p)[names(p)!="p"], names(s))
print("Fitting starting... p = zero\n")
start_time <- Sys.time()
simultaneous_fit_frac <- map(simultaneous_flow_data_fitting, ~fit(datas = .,
odes = flow_frac,
free = freepars,
lower = c("a.k" = 10,
"b.k" = 1.0001,
"c.k" = 0.001,
"a" = 500,
"b" = 1.0001,
"c" = 0.01,
"Theta" = 0.1,
"mu" = 0.01,
"beta" = 0.1,
"Kplus" = 10,
"Y" = 100,
"lp" = 0.01,
"N" = 1000),
upper = c("a.k" = 5000,
"b.k" = 5,
"c.k" = 2,
"a" = 5000,
"b" = 4,
"c" = 2,
"Theta" = 2,
"mu" = 0.1,
"beta" = 1,
"Kplus" = 500,
"Y" = 1e5,
"lp" = 0.8,
"N" = 1e7),
method = "Marq",
fun = fun_log,
show = NULL
#    ymax = 0.3
#bootstrap = nboots
)
)
print("Fitting ended")
end_time <- Sys.time()
print(end_time - start_time)
shapiro <- map(simultaneous_fit_frac, ~shapiro.test(.[["residuals"]]))
flow_sim_frac_pointest_p_zero <- simultaneous_fit_frac
save(flow_sim_frac_pointest_p_zero, file = "DataObjects/flow_sim_frac_pointest_p_zero.Rdata")
# F tests!
#----F test for adding p as a free parameter
load("DataObjects/flow_sim_frac_pointest_p_free.Rdata")
load("DataObjects/flow_sim_frac_pointest_p_zero.Rdata")
stop()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
packages <- c("tidyverse", "ggplot2", "readr", "forcats", "cowplot")
lapply(packages, require, character.only = TRUE)
install.packages("cowplot", dependencies = TRUE)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
packages <- c("tidyverse", "ggplot2", "readr", "forcats")
lapply(packages, require, character.only = TRUE)
tmp=lapply(packages, require, character.only = TRUE)
load("DataObjects/flow_sim_frac_pointest_p_free.Rdata")
load("DataObjects/flow_sim_frac_pointest_p_zero.Rdata")
load("DataObjects/flow_frac_pointest_p_zero.Rdata")
load("DataObjects/flow_frac_pointest_p_free.Rdata")
F<-function(SSR1,SSR2,p1,p2,n){
f1<-(SSR1-SSR2)/(p2-p1)
f2<-SSR2/(n-p2)
f<-f1/f2
p_val<-1-pf(f, p2-p1, n-p2, lower.tail=F)
return(p_val)
}
# compare p free and p=0 fits for the flow frac model with fixed thymic functions
p1 <- rep(5,2)#Theta,mu, beta, lp, N
p2 <- rep(6,2)#Theta,mu, beta, p, lp, N
n <- c(43,42)
SSR1<-map(flow_sim_frac_pointest_p_zero, ~.$ssr)  # enter SSR model with less parameters
SSR2<-map(flow_sim_frac_pointest_p_free, ~.$ssr)  # enter SSR model with more parameters
F_flow_frac <- map(c(1,2), ~ F(SSR1[[.]],SSR2[[.]],p1[[.]],p2[[.]],n[[.]]))
p1 <- rep(10,2)#f,a,b,c,a2,b2,c2,theta,mu,beta
p2 <- rep(11,2)#f,a,b,c,a2,b2,c2,theta,mu,beta,p
n <- c(42,42)
SSR1<-map(flow_sim_frac_pointest_p_zero, ~.$ssr)  # enter SSR model with less parameters
SSR2<-map(flow_sim_frac_pointest_p_free, ~.$ssr)  # enter SSR model with more parameters
F_flow_frac_sim <- map(c(1,2), ~ F(SSR1[[.]],SSR2[[.]],p1[[.]],p2[[.]],n[[.]]))  # give p-value for H0: hance that data generated under null hyp (=simpler model) ,
cat("CD4 flow frac", F_flow_frac[[1]], "\n")
cat("CD8 flow frac", F_flow_frac[[2]], "\n")
cat("CD4 flow frac sim", F_flow_frac_sim[[1]], "\n")
cat("CD4 flow frac sim", F_flow_frac_sim[[2]], "\n")
# compare p free and p=0 fits for the flow frac model with fixed thymic functions
p1 <- rep(5,2)#Theta,mu, beta, lp, N
p2 <- rep(6,2)#Theta,mu, beta, p, lp, N
n <- c(43,42)
SSR1<-map(flow_sim_frac_pointest_p_zero, ~.$ssr)  # enter SSR model with less parameters
SSR2<-map(flow_sim_frac_pointest_p_free, ~.$ssr)  # enter SSR model with more parameters
SSR1
SSR2
F_flow_frac <- map(c(1,2), ~ F(SSR1[[.]],SSR2[[.]],p1[[.]],p2[[.]],n[[.]]))
F_flow_frac
?AIC
AIC(flow_frac_pointest_p_free)
AIC(flow_frac_pointest_p_free[[1]])
p1 <- rep(10,2)#f,a,b,c,a2,b2,c2,theta,mu,beta
p2 <- rep(11,2)#f,a,b,c,a2,b2,c2,theta,mu,beta,p
n <- c(42,42)
SSR1<-map(flow_sim_frac_pointest_p_zero, ~.$ssr)  # enter SSR model with less parameters
SSR2<-map(flow_sim_frac_pointest_p_free, ~.$ssr)  # enter SSR model with more parameters
SSR1
SSR2
source("~/Dropbox/Documents/Projects/Collaborations/Eva Lukas/R scripts/fitting/F_test.R")
# compare p free and p=0 fits for the flow frac model with fixed thymic functions
p1 <- rep(5,2)#Theta,mu, beta, lp, N
p2 <- rep(6,2)#Theta,mu, beta, p, lp, N
n <- c(43,42)
SSR1<-map(flow_frac_pointest_p_zero, ~.$ssr)  # enter SSR model with less parameters
SSR2<-map(flow_frac_pointest_p_free, ~.$ssr)  # enter SSR model with more parameters
